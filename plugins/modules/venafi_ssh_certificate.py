#!/usr/bin/env python3
# -*- coding: utf-8 -*-
# Copyright 2019 Venafi, Inc.
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#  http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
#
from __future__ import absolute_import, print_function, unicode_literals

DOCUMENTATION = """
---
module: venafi_ssh_certificate
short_description: Requests and retrieves SSH certificates from Venafi platforms.
description:
    - This is the Venafi SSH certificate module for working with Venafi Trust Protection Platform.
    - It allows to request and retrieve SSH certificates.
version_added: "0.7.0"
author: Russel Vela (@rvelaVenafi)
options:
    cert_path:
        description:
            - Remote absolute path where the generated certificate file should be created or is already located.
        required: true
        type: path
    public_key_path:
        description:
            - The path where the public key is going to be stored in the remote host.
            - If I(ssh_key_generation_type) is C(provided), this option indicates the path to the public key to load.
        type: path
    private_key_path:
        description:
            - The path where the private key is going to be stored in the remote host.
            - Ignored when I(ssh_key_generation_type) is "provided"
        type: path
    ssh_key_generation_type:
        description:
            - The generation type of the SSH Key Pair.
            - C(provided). The user provides a file path I(public_key_path) to load the public key data.
            - C(local). The SSH Key Pair is generated by the vcert library. 
            - C(service). The SSH Key Pair is generated by the TPP server and returned in the response.
            - SSH Key Pair are saved if I(public_key_path) and I(private_key_path) are defined.
        default: provided
        choices:
            - local
            - service
            - provided
        type: str
    private_key_passphrase:
        description:
            - The passphrase to encrypt the private key.
            - Ignored when I(ssh_key_generation_type) is C(provided).
        type: str
    ssh_key_size:
        description:
            - Size (in bits) of the SSH key to generate.
        required: false
        default: 3072
        choices:
            - 2048
            - 3072
            - 4096
        type: int
    cadn:
        description:
            - The DN of the issuing certificate template which will be used for signing.
        required: true
        type: str
    key_id:
        description:
            - The identifier of the requested certificate.
        required: true
        type: str
    validity_period:
        description:
            - How much time the requester wants to have the certificate valid.
            - The minimum is 1 second and the maximum is (at least) 20 years.
            - The operation will not be rejected if the requested validity is bigger than the validity period set on
              the certificate template, but the certificate will be valid for the value set on the template.
            - |- 
                Accepted patterns are:
                    b(Relative time) b(s), b(m), b(h), b(d), and b(w). Example: b(1w 2d 3h 4m 50s).
                    b(Static end day) in format of b(yyyyMMdd) or b(yyyyMMddHHmmss). Example: b(20241230).
        type: str
    policy_dn:
        description:
            - The DN of the policy folder where the certificate object will be created.
            - If this is not specified, then the policy folder specified on the certificate template will be used.
        type: str
    object_name:
        description:
            - The friendly name for the certificate object.
            - If I(object_name) is not specified, then I(key_id) is used.
        type: str
    destination_addresses:
        description:
            - >-
                The address (FQDN/hostname/IP/CIDR) of the destination host where the certificate will be used
                to authenticate to.
        type: list
        elements: str
    principals:
        description:
            - The requested principals. 
            - If no value is specified, then the default principals from the certificate template will be used.
        type: list
        elements: str
    extensions:
        description:
            - The requested certificate extensions. 
            - >-
                Example: "Extensions" : {"permit-pty": "", "permit-port-forwarding": "", 
                "login@github.com": "alice@github.com"}
        type: list
        elements: str
    force_command:
        description:
            - >-
                The requested force command. Example. "ForceCommand": "/usr/scripts/db_backup.sh"
        type: 
    source_addresses:
        description:
            - >-
                The requested source addresses as list of IP/CIDR. Example: ["192.168.1.1/24", "10.0.0.1"]
        type: list
        elements: str
    windows_cert:
        description:
            - The flag indicates that the certificate is intended to be used in a Windows environment.
            - Break Lines and Carriage Returns will be adjusted accordingly to work on Windows.
        default: false
        type: bool
extends_documentation_fragment:
    - files
    - venafi.machine_identity.common_options
"""

EXAMPLES = """
"""

RETURN = """
ssh_keypair_generation:
    description: The mode used to generate the public and private keys.
    returned: always
    type: bool
    sample: True

ssh_certificate_filename:
    description: Path to the signed certificate.
    returned: always
    type: path
    sample: /etc/ssh/venafi.example-cert.pub

ssh_public_key_filename:    
    description: Path to the generated or provided public key.
    returned: always
    type: path
    sample: /etc/ssh/venafi.example.pub

ssh_private_key_filename:
    description: Path to the generated private key.
    returned: when I(ssh_key_generation_type) is not C(provided)
    type: path
    sample: /etc/ssh/venafi.example
"""

import os

from ansible.module_utils.basic import AnsibleModule
try:
    from ansible_collections.venafi.machine_identity.plugins.module_utils.common_utils \
        import get_venafi_connection, module_common_argument_spec, venafi_common_argument_spec
except ImportError:
    from plugins.module_utils.common_utils \
        import get_venafi_connection, module_common_argument_spec, venafi_common_argument_spec

HAS_VCERT = True
try:
    from vcert import CommonConnection, SSHCertRequest, SSHKeyPair, write_ssh_files
    from vcert.ssh_utils import SSHRetrieveResponse
except ImportError:
    HAS_VCERT = False

MSG_CERT_FILE_NOT_FOUND = "SSH Certificate file does not exist"
SSH_GEN_TYPE_PROVIDED = 'provided'
SSH_GEN_TYPE_LOCAL = 'local'
SSH_GEN_TYPE_SERVICE = 'service'

F_CERT_FILE_EXISTS = 'cert_file_exists'
F_CHANGED = 'changed'
F_CHANGED_MSG = 'changed_msg'

F_STATE = 'state'
F_FORCE = 'force'

F_CERT_PATH = 'cert_path'
F_PRIVATE_KEY_PATH = 'private_key_path'
F_PUBLIC_KEY_PATH = 'public_key_path'
F_WINDOWS_CERT = 'windows_cert'

F_SSH_KEY_GEN_TYPE = 'ssh_key_generation_type'
F_PRIVATE_KEY_PASS = 'private_key_passphrase'
F_SSH_KEY_SIZE = 'ssh_key_size'
F_CADN = 'cadn'
F_KEY_ID = 'key_id'
F_VALIDITY_PERIOD = 'validity_period'
F_POLICY_DN = 'policy_dn'
F_OBJECT_NAME = 'object_name'
F_DEST_ADDRESSES = 'destination_addresses'
F_PRINCIPALS = 'principals'
F_EXTENSIONS = 'extensions'
F_FORCE_COMMAND = 'force_command'
F_SRC_ADDRESSES = 'source_addresses'


class VSSHCertificate:
    def __init__(self, module):
        """
        :param AnsibleModule module:
        """
        self.module = module  # type: AnsibleModule
        self.connection = get_venafi_connection(module)  # type: CommonConnection
        self.state = module.params[F_STATE]  # type: str
        self.force = module.params[F_FORCE]  # type: bool
        # SSH keypair attributes
        self.ssh_key_generation_type = module.params[F_SSH_KEY_GEN_TYPE]  # type: str
        self.private_key_passphrase = module.params[F_PRIVATE_KEY_PASS]  # type: str
        self.ssh_key_size = module.params[F_SSH_KEY_SIZE]  # type: int
        # SSH Certificate attributes
        self.cadn = module.params[F_CADN]  # type: str
        self.key_id = module.params[F_KEY_ID]   # type: str
        self.validity_period = module.params[F_VALIDITY_PERIOD]   # type: str
        self.policy_dn = module.params[F_POLICY_DN]   # type: str
        self.object_name = module.params[F_OBJECT_NAME]   # type: str
        self.destination_addresses = module.params[F_DEST_ADDRESSES]   # type: list
        self.principals = module.params[F_PRINCIPALS]   # type: list
        self.extensions = module.params[F_EXTENSIONS]   # type: list
        self.force_command = module.params[F_FORCE_COMMAND]   # type: str
        self.source_addresses = module.params[F_SRC_ADDRESSES]   # type: list
        # SSH files attributes
        self.certificate_filename = module.params[F_CERT_PATH]  # type: str
        self.public_key_filename = module.params[F_PUBLIC_KEY_PATH]  # type: str
        self.private_key_filename = module.params[F_PRIVATE_KEY_PATH]  # type: str
        self.windows_cert = module.params[F_WINDOWS_CERT]  # type: bool

        self.changed = False
        self.private_key_changed = False

    def check(self):
        """
        Validates if the resources have changed since the last execution

        :return: a dictionary with the results of the validation
        :rtype: dict[Any, Any]
        """
        result = dict()

        cert_file_exists = False
        if os.path.exists(self.certificate_filename):
            cert_file_exists = True
        if self.state == 'present':
            # Validate that a public key file has been passed when key generation is "provided"
            if self.ssh_key_generation_type == SSH_GEN_TYPE_PROVIDED:
                if not os.path.exists(self.public_key_filename):
                    self.module.fail_json(msg="File not found. "
                                              "[%s] field is required when SSH key generation type is [%s]."
                                              % (F_PUBLIC_KEY_PATH, SSH_GEN_TYPE_PROVIDED))
            if cert_file_exists:
                result = {
                    F_CERT_FILE_EXISTS: True,
                    F_CHANGED: True,
                    F_CHANGED_MSG: "SSH Certificate found. Requesting a new one with key id %s" % self.key_id,
                }
            else:
                result = {
                    F_CERT_FILE_EXISTS: False,
                    F_CHANGED: True,
                    F_CHANGED_MSG: MSG_CERT_FILE_NOT_FOUND,
                }
        elif self.state == 'absent':
            if cert_file_exists:
                # If cert exists, it must be revoked/deleted from host
                result = {
                    F_CERT_FILE_EXISTS: True,
                    F_CHANGED: True,
                    F_CHANGED_MSG: "SSH Certificate found. Deleting it from host."
                }
            else:
                # If cert does not exist, no change is required.
                result = {
                    F_CERT_FILE_EXISTS: False,
                    F_CHANGED: False,
                    F_CHANGED_MSG: "SSH certificate not found. No action required."
                }
        return result

    def validate(self):
        """
        Ensures the policy specification resource is in its desired state.
        Otherwise raises an error

        :return: None
        """
        result = self.check()
        if self.state == 'absent' and result[F_CHANGED]:
            self.module.fail_json(
                msg="Operation validation failed. No changes should be found after execution. Found: %s"
                    % result[F_CHANGED_MSG])

        return result

    def enroll(self):
        ssh_request = SSHCertRequest(
            cadn=self.cadn,
            key_id=self.key_id,
            validity_period=self.validity_period,
            policy_dn=self.policy_dn,
            object_name=self.object_name,
            destination_addresses=self.destination_addresses,
            principals=self.principals,
            extensions=self.extensions,
            force_command=self.force_command,
            source_addresses=self.source_addresses
        )

        if self.ssh_key_generation_type == SSH_GEN_TYPE_PROVIDED:
            with open(self.public_key_filename, 'r') as pub_key:
                data = pub_key.read()
                ssh_request.set_public_key_data(data)
        elif self.ssh_key_generation_type == SSH_GEN_TYPE_LOCAL:
            ssh_kp = SSHKeyPair()
            ssh_kp.generate(key_size=self.ssh_key_size, passphrase=self.private_key_passphrase)
            ssh_request.set_public_key_data(ssh_kp.public_key())

        success = self.connection.request_ssh_cert(ssh_request)
        if not success:
            self.module.fail_json(msg="Failed to request certificate with key id %s" % ssh_request.key_id)

        response = self.connection.retrieve_ssh_cert(ssh_request)

        if self.ssh_key_generation_type == SSH_GEN_TYPE_LOCAL:
            response.private_key_data = ssh_kp.private_key()

        if response:
            self._write_response(response)

    def _write_response(self, response):
        """
        :param SSHRetrieveResponse response:
        :rtype: None
        """
        cert_data = response.certificate_data
        private_key_data = None
        public_key_data = None
        if self.ssh_key_generation_type is not SSH_GEN_TYPE_PROVIDED:
            private_key_data = response.private_key_data
            public_key_data = response.public_key_data

        with open(self.certificate_filename, "wb") as cert_file:
            cert_file.write(cert_data.encode())
            self.changed = True

        if private_key_data:
            if not self.windows_cert:
                private_key_data = private_key_data.replace("\r\n", "\n")
            with open(self.private_key_filename, "wb") as private_key_file:
                private_key_file.write(private_key_data.encode())
                self.private_key_changed = True

        if public_key_data:
            with open(self.public_key_filename, "wb") as public_key_file:
                public_key_file.write(public_key_data.encode())

    def revoke(self):
        self.module.fail_json(msg='SSH certificate revoke operation not supported by vcert library')

    def directory_exist(self):
        cert_dir = os.path.dirname(self.certificate_filename or "/a")
        private_key_dir = os.path.dirname(self.private_key_filename or "/a")
        public_key_dir = os.path.dirname(self.public_key_filename or "/a")
        ok = True
        for p in {cert_dir, private_key_dir, public_key_dir}:
            if os.path.isdir(p):
                continue
            elif os.path.exists(p):
                self.module.fail_json(msg="Path %s already exists but is not a directory." % p)
                ok = False
            elif not os.path.exists(p):
                self.module.fail_json(msg="Path %s does not exist." % p)
                ok = False
            else:
                ok = False
        return ok

    def dump(self):
        result = {
            'changed': self.changed,
            'ssh_keypair_generation': self.ssh_key_generation_type,
            'ssh_certificate_filename': self.certificate_filename,
            'ssh_public_key_filename': self.public_key_filename,
        }
        if self.private_key_changed:
            result['ssh_private_key_filename'] = self.private_key_filename

        return result


def main():
    # the AnsibleModule object will be our abstraction working with Ansible
    # this includes instantiation, a couple of common attr would be the
    # args/params passed to the execution, as well as if the module
    # supports check mode
    args = module_common_argument_spec()
    args.update(venafi_common_argument_spec())
    args.update(
        # SSH files attributes
        path=dict(type='path', aliases=['cert_path'], required=True),
        public_key_path=dict(type='path', required=False),
        private_key_path=dict(type='path', required=False),
        # SSH KeyPair attributes
        ssh_key_generation_type=dict(type='str',
                                     choices=[SSH_GEN_TYPE_PROVIDED, SSH_GEN_TYPE_LOCAL, SSH_GEN_TYPE_SERVICE],
                                     default=SSH_GEN_TYPE_PROVIDED),
        private_key_passphrase=dict(type='str', no_log=True),
        ssh_key_size=dict(type='int', choices=[2048, 3072, 4096], default=3072, required=False),
        # SSH Certificate attributes
        cadn=dict(type='str', required=True),
        key_id=dict(type='str', required=True),
        validity_period=dict(type='str', required=False),
        policy_dn=dict(type='str', required=False),
        object_name=dict(type='str', required=False),
        destination_addresses=dict(type='list', elements='str', required=False),
        principals=dict(type='list', elements='str', required=False),
        extensions=dict(type='list', elements='str', required=False),
        force_command=dict(type='str', required=False),
        source_addresses=dict(type='list', elements='str', required=False),
        windows_cert=dict(type='bool', default=False, required=False)
    )
    module = AnsibleModule(
        # define the available arguments/parameters that a user can pass to the module
        argument_spec=args,
        supports_check_mode=True,
        add_file_common_args=True,
    )

    if not HAS_VCERT:
        module.fail_json(msg='"vcert" python library is required')

    vcert = VSSHCertificate(module)
    check_result = vcert.check()
    if module.check_mode:
        module.exit_json(**check_result)

    if vcert.state == 'present' and (check_result[F_CHANGED] or vcert.force):
        if not vcert.directory_exist():
            module.fail_json(msg="One or more directory do not exist.")
        vcert.enroll()
    elif vcert.state == 'absent' and (check_result[F_CHANGED] or vcert.force):
        # revoke/delete cert here
        vcert.revoke()

    vcert.validate()
    result = vcert.dump()
    module.exit_json(**result)


if __name__ == '__main__':
    main()
